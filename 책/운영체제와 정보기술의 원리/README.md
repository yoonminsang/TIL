# [인강](http://www.kocw.net/home/search/kemView.do?kemId=1046323)

## 컴퓨터 구조 용어 정리(책X)

- CPU(Central Processing Unit, 중앙처리장치): 컴퓨터 시스템의 두뇌 역할
- 주기억장치(메모리)
  - CPU가 처리할 데이터와 명령어를 임시로 저장하는 물리적 장치.
  - CPU가 접근하여 데이터를 처리할 수 있는 메모리
  - 빠르지만 용량이 작음. 휘발성임.
  - RAM(Random Access Memory): 현재 작업중인 데이터와 프로그램을 일시적으로 저장(현대에는 DRAM, SDRAM, DDR SDRAM 등으로 사용)
  - ROM(Read Only Memory) : 영구적 저장. 비휘발성
- 보조기억장치
  - 1. 파일 시스템용
    - 주기억장치의 용량 한계와 휘발성을 보완하기 위한 저장 장치
    - 비휘발성, 고용량, 저렴, 느림
    - HDD, SSD, USB, CD/DVD, 테이프
  - 2. 메모리의 연장 공간인 스왑영역
    - 당장 사용하지 않는 부분은 디스크의 스왑 영역에 내려놓는다.(스왑 아웃)
    - 필요할때 다시 메모리 영역으로 올린다.
- 캐시 메모리: CPU와 RAM 사이에 위치한 고속 메모리

# 1장. 컴퓨터 및 정보 기술의 역사

# 2장. 운영체제 개요

## 1. 운영체제의 정의

- 운영체제(operating system): 컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어
- 운영체제가 없으면 컴퓨터는 고철 덩어리에 불과하다. 이 고철 덩어리(하드웨어)를 동작시키기 위해서 필요한 기본적인 소프트웨어가 운영체제다.
- 컴퓨터의 전원을 켜면 운영체제는 이와 동시에 실행된다.
- 운영체제도 소프트웨어이기 때문에 메모리에 올려야한다. 하지만 운영체제는 큰 규모의 프로그램이기 때문에 메모리 이슈가 존재한다.
- 이를 막기 위해서 필요한 부분만 메모리에 올려서 사용한다. 이때 메모리에 상주하는 운영체제의 부분을 **커널(kernel)**이라고 한다.

## 2. 운영체제의 기능

- 운영체제는 하드웨어를 위한 역할과 사용자를 위한 역할 두가지가 존재한다.
- = 컴퓨터 시스템 내의 자원(resource)를 효율적으로 관리하는 것과 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공
- 후자는 결국 복잡한 컴퓨터를 유저에게 추상화시켜서 보여줌을 의미한다.
- 전자의 이유로 운영체제를 자원관리자(resource manager)라고 부른다. 즉, CPU, 메모리, 하드디스크 등 하드웨어 자원뿐 아니라 소프트웨어 자원까지 효율적으로 관리해 가장 좋은 성능을 내도록 하는 역할을 담당한다. 그와 동시에 형평성있게 분배해야하기 때문에 균형자 역할도 수행한다. + 보안도 담당한다.

## 3. 운영체제의 분류

- 단일작업(single tasking)용 운영체제: 한 번에 하나의 프로그램만 실행(예전)
- 다중작업(multi tasking)용 운영체제: 2개 이상의 프로그램 처리 가능

- 시분할 시스템(time sharing system): CPU의 작업시간을 여러 프로그램들이 조금씩 나누어 쓰는 시스템

- 다중 프로그래밍 시스템(multi-programming system): 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템
  (CPU와 달리 메모리는 여러 프로그램을 올릴 수 있다.)

- 대화형 시스템(interactive system): 각 프로그램에 대한 키보드의 입력의 결과를 곧바로 화면에 보여줌.

> 우리가 사용하는 PC는 위 시스템을 모두 사용하고 있다.

- 다중처리기 시스템(multi-processor system): 하나의 컴퓨터 안에 CPU가 여러 개 설치된 경우
  (현대의 일반 PC에서는 사용할 일 없음. 처리가 빨라지지만 운영체제 입장에서는 복잡한 메커니즘이 필요함)

- 단일 사용자용 운영체제: 한 번에 한 명의 사용자만이 사용하도록 허용하는 운영체제
- 다중 사용자용 운영체제: 여러 사용자가 동시에 접속해 사용할 수 있게 하는 운영체제

> 요즘은 단일 사용자용 운영체제에서 서버 기능을 지원해 다중 사용자용 운영체제로 사용된다.

- 일괄처리(batch processing): 요청된 작업을 일정량씩 모아서 한꺼번에 처리하는 방식 => 응답시간이 느림
- 시분할 방식: 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식(현대 컴퓨터에서 사용)
  (대화형 시스템은 시분할 방식의 대표적인 특징이다.)

- 실시간(real-time) 운영체제: 정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장해야하는 시스템
  - 경성 실시간 시스템(hard realtime system): 시간을 지키지 못했을 때 매우 위험한 결과(로켓, 원자로 제어)
  - 연성 실시간 시스템(soft realtime system): 멀티미디어 스트리밍 시스템과 같이 데이터가 정해진 시간 단위로 전달되어야 올바른 기능을 수행할 수 있는 시스템

## 4. 운영체제의 예

- 윈도우는 초기에는 MS-DOS 위에서 수행되는 프로그램이라는 한계가 있었지만 점점 발전해서 온전한 운영체제로 제작되었다.
- 유닉스는 프로그램 개발 환경을 위해 설계된 운영체제로서 이식성(portability)이 좋고, 운영체제 커널의 크기가 작으며, 소스 코드가 공개되었다는 점 등으로 인해 가장 널리 사용되는 운영체제가 되었다.
- 이식성: 해당 소프트웨어를 다른 기종의 기계로 옮기는 것이 얼마나 용이한가를 나타내는 지표

## 5. 운영체제의 자원 관리 기능

- 운영체제의 가장 핵심적인 기능은 자원을 효율적으로 관리하는 것.(하드웨어, 소프트웨어 자원)
- 하드웨어 자원: CPU, 메모리, 주변장치, 입출력 장치
- CPU: 여러 프로세스들이 효율적으로 나누어 사용할 수 있게 관리
- 메모리: 시스템 내에 한정된 용량. 여러 프로세스들이 나누어 쓸 수 있도록 해야함
- 보조기억장치(하드): 전원이 꺼지면 정보가 모두 지워지기 때문에 보조기억장치에 파일 형태로 저장해야함.

- CPU가 하나밖에 없는 구조에서도 프로세스는 여러 개가 동시에 수행될 수 있다.
- CPU 스케줄링: 매 시점 어떠한 프로세스에 CPU를 할당해 작업을 처리할지 결정하는일.
- 1. 효율, 2. 공평
- CPU 스케줄링 종류: 선입선출, 라운드로빈, 우선순위
- 라운드로빈: CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한

- 물리적 메모리를 관리하는 방식: 고정분할 방식, 가변분할 방식, 가상메모리 방식
- 고정분할방식: 물리적 메모리를 몇 개의 분할로 미리 나누어서 관리. 융통성이 없음. 분할의 크기보다 큰 프로그램은 적재 불가능
- 내부조각(internal fragmentation): 고정된 메모리에 프로그램을 올리고 남은 메모리(분할의 크기보다 작은 프로그램이 적재되는 경우 남는 영역)
- 가변분할 방식: 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식. 물리적 메모리의 크기보다 더 큰 프로그램의 실행은 여전히 불가능
- 외부조각(external fragmentation): 전체 남은 메모리는 충분하지만 연속된 공간이 아니라 작은 조각들로 흩어져 있어 새 프로그램을 올릴 수 없는 상황(프로그램에 할당되지는 않았지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역)
- 가상메모리: 현대에 가장 많이 사용됌. 물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원. 모든 프로그램은 가상 메모리 주소를 가지고 매핑하는 기술을 이용해 물리적 메모리 주소로 변환 후 물리적 메모리에 올림. 프로그램의 전체 크기가 2gb라고 해도 전체가 항상 동시에 사용되지는 않는다. 현재 사용되고 있는 부분만 메모리에 올리고 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재한다.
- 스왑 영역: 위 설명의 보조장치의 영역
- 가상메모리공간은 페이지라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다. 이러한 기법을 페이징 기법이라고 한다.

- 인터럽트: 주변장치 및 입출력 장치는 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하는데, 이때 발생시키는 신호를 인터럽트라 한다.
- 주변장치들은 작은 CPU를 가지고 있다. 이를 컨트롤러라고 부른다.
- 운영체제는 인터럽트가 발생하면 직전에 수행하던 작업의 상태를 저장해둔다.

> 3장과 4장은 전체적인 흐름을 아는 것이 중요하다. 위의 인강을 듣는게 도움이 된다.

# 3장. 컴퓨터 시스템의 동작원리

## 1. 컴퓨터 시스템의 구조

- 컴퓨터 시스템 구조
  - 내부장치: CPU, 메모리
  - 외부장치(입출력장치): 디스크, 키보드, 마우스, 모니터, 네트워크 장치 등
- 메모리 및 입출력장치 등의 각 하드웨어 장치에는 컨트롤러가 붙어 있다. 이는 작은 CPU다.
- 프로그램이 수행되려면 프로그램이 메모리에 올라가있어야한다.

## 2. CPU 연산과 I/O 연산

- 입출력장치와 메인 CPU는 동시 수행이 가능하다.
- 로컬버퍼: 장치 컨트롤러에 있는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리
- 디스크나 키보드에서 데이터를 읽어오는 경우, 우선 로컬버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다. 이때 장치에서 로컬버퍼로 읽어오는 일은 컨트롤러가 담당한다.
- ex) 프로그램 B 실행 => B에서 디스크 데이터를 읽어오라는 명령 => 디스크 컨트롤러가 디스크에서 내용을 읽어 로컬버퍼에 저장 => 장치 컨트롤러가 CPU에 인터럽트를 발생시켜 보고
- 기본적으로 CPU는 매 시점 메모리에서 명령(instruction)을 하나씩 읽어와서 수행한다. 이때 CPU 옆에 있는 인터럽트 라인이 있어서 인터럽트 라인에 신호가 들어오면 하던일을 멈추고 인터럽트와 관련된 일을 먼저 처리한다.
  - 더 정확히 설명하면, CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지를 확인한다. 발생했다면 인터럽트 처리를 먼저 한다.

## 3. 인터럽트의 일반적 기능

- 운영체제 커널에는 인터럽트가 들어왔을 때 해야 할 일이 미리 프로그래밍 되어 있다.
- 운영체제는 하드웨어, 소프트웨어 자원 관리 뿐만 아니라 사용자 프로그램에 필요한 서비스도 제공한다.
- 그 중 하나가 인터럽트루틴이다.
- 인터럽트루틴이 하는일: 디스크의 로컬버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달하고, 해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시
- 인터럽트에는 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다.
  - 하드웨어 인터럽트: 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅한다.(일반적인 인터럽트)
  - 소프트웨어 인터럽트(트랩. trap): 소프트웨어가 그 일을 수행한다.
    - 예외상황(exception): 비정상적인 시도
    - 시스템 콜(system call): 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법.
      - 인터럽트 라인 세팅을 통해 CPU 제어권을 운영체제로 넘겨 실행
      - ex) 애플리케이션 개발자가 프로그램 작성 중 키보드 입력이나 화면 출력 등의 입출력 작업이 필요한 경우 직접 입출력 코드를 작성하는 것이 아니라 이미 존재하는 커널의 코드를 호출해서 처리
- 인터럽트 백터: 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 가리키고 있는 자료구조
- 실제 처리해야 할 코드는 인터럽트 처리루틴(interrupt service routine) 또는 인터럽트 핸들러라고 불리는 다른 곳에 정의된다.

## 4. 인터럽트 핸들링

- 인터럽트 핸들링: 인터럽트가 발생한 경우에 처리해야 할 일의 절차
- CPU에서 명령이 실행될 때에는 CPU 내부에 있는 임시 기억장치인 레지스터에 데이터를 읽거나 쓰면서 작업을 한다.
- ex) 프로그램 A 실행 => 인터럽트 발생 => A의 현재 상태 저장(상태: CPU에서 실행중인 메모리 주소, 부가정보)(인터럽트가 발생하면 기존 레지스터가 사라짐) => 이것을 모두 저장한 후에야 인터럽트 처리가 가능함
- 운영체제는 현재 시스템 내에서 실행되는 프로그램을 관리하기 위해 프로세스 제어블록(Process Control Block: PCB)이라는 자료구조를 둔다.
- PCB는 각각의 프로그램마다 하나씩 존재. 해당 프로그램의 어느 부분이 실행 중이었는지를 저장. 구체적으로는 실행중이던 코드의 메모리 주소, 레지스터값, 하드웨어 상태 등이 저장
- ex) 프로그램이 실행 => 인터럽트 발생 => 프로그램의 실행 상태를 PCB에 저장 => CPU의 제어권이 인터럽트 처리루틴으로 넘어감 => 인터럽트 처리가 끝나면 저장된 상태를 PCB로부터 CPU상에 복원해 인터럽트 당하기 직전의 위치부터 실행이 이어짐

## 5. 입출력 구조

- 동기식 입출력(synchronous I/O): 어떤 프로그램이 입출력 요청을 했을 때 입출력 작업이 완료된 후에야 그 프로그램이 후속 작업을 수행할 수 있는 방식
- IO연산은 CPU보다 느리다. 그렇기 때문에 입출력이 완료될때까지 CPU를 기다리면 자원이 낭비된다.
- 따라서 일반적으로 프로그램이 입출력을 수행 중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속 쉬지 않고 일할 수 있도록 관리한다.
- 입출력이 완료될때까지는 해당 프로그램에 CPU를 할당하지 않는다.
- 운영체제는 프로그램을 몇 가지 상태로 나누고 입출력 중인 프로그램의 경우 봉쇄 상태(blocked state)로 전환시킨다.
- blocked state: CPU를 할당하지 않고, CPU 할당 시 곧바로 명령을 수행할 수 있는 프로그램에게만 CPU를 할당한다.
- 입축력 요청의 동기화를 위해 입출력 장치별로 큐를 두어 요청한 순서대로 처리할 수 있도록 한다.
- 비동기식 입출력: 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식
- 예시를 생각해보고 생각안나면 p79 읽기.

## 6. DMA

- 메모리는 원칙적으로 CPU에 의해서만 접근 가능
- 그런데 모든 메모리 접근 연산이 CPU에 의해서만 이루어지면 효율성이 떨어짐
- 비효율을 극복하기 위해 CPU 이외에 메모리 접근이 가능한 장치를 하나 더 두는 경우가 많음. 이를 DMA(Direct Memory Access)라고 한다.
- byte 단위가 아니라 block이라는 큰 단위로 메모리 읽어온 후 CPU에게 인터럽트를 발생시켜 작업 완료를 알려줌

<img src="./images/DMA.jpeg">

## 7. 저장장치의 구조

- 컴퓨터 시스템을 구성하는 저장장치는 주기억장치와 보조기억장치로 나뉜다.
- 주기억장치: 메모리라고 불림. 전원이 나가면 사라지는 휘발성. RAM
- 보조기억장치: 전원이 나가도 사라지지 않는 비휘발성. 마그네틱 디스크, 플래시 메모리, CD, 마그네틱 테이프
  - 첫번째 용도. 파일 시스템용
  - 두번째 용도. 메모리의 연장 공간인 스왑 영역
    - 당장 사용하지 않는 부분은 디스크의 스왑 영역에 내려놓는다.(스왑 아웃)
    - 필요할때 다시 메모리 영역으로 올린다.
    - 주로 하드디스크가 사용됌
    - 비휘발성 용도와는 역할이 구분됌

## 8. 저장장치의 계층 구조

--- CPU 내부 계층

- 레지스터(가장 빠름, 비쌈, 용량 적음)
- 캐시 메모리
- 메인 메모리

---- 저장장치 계층

- 마그네틱 디스크
- 광디스크
- 마그네틱 테이프

---

- 캐싱 기법사용하면 적은 용량의 캐시 메모리를 사용해서도 메인 메모리와 같이 큰 용량을 가진 것처럼 효율적으로 동작하도록 관리할 수 았다.

## 9. 하드웨어의 보안

- 하드웨어적인 보안을 유지하기 위해서 운영체제는 커널모드와 사용자모드의 두 가지 모드를 지원한다.
- 커널모드: 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행하는 모드. 모든 명령 가능
- 사용자모드: 일반 사용자 프로그램이 실행되면 제한적인 명령만을 수행할 수 있다.
- CPU 내부에 모드비트(mode bit)를 두고 0이면 커널모드, 1이면 사용자모드로 간주해서 검증한다.
- 특권명령: 시스템의 보안과 관련된 명령. 모드비트가 0일때에만 수행 가능
- ex) 입출력은 특권명령이다. 사용자모드에서 입출력이 필요하면 시스템콜로 운영체제에 요청해야한다. 그러면 운영체제가 CPU를 할당받고 인터럽트 벡터의 특정 위치를 통해 해당 인터럽트 처리루틴으로 이동한다. 이때 인터럽트 하드웨어에 의해 모드비트가 0으로 세팅되어 운영체제는 입출력을 수행할 수 있게 된다.

## 10. 메모리 보안

- 여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 다른 사용자 프로그램에 접근을 하면 안돼. 그래서 메모리 보안이 필요
- 기준 레지스터(base register), 한계 레지스터(limit register)를 사용해서 메모리 보호
  - base register는 메모리상의 가장 작은 주소, limit register는 base register값부터 접근할 수 잇는 메모리의 범위
  - 잘못된 범위의 주소에 접근하면 소프트웨어 인터럽트 > 예외상황(exception) 일으킴.
  - 단, 이건 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 단순화된 메모리 관리 기법에만 해당됌. 페이징은 다른 방법이 필요함
- 메모리 접근 연산은 특권명령은 아니지만, base register와 limit register 값을 세팅하는 연산은 특권명령이다.
- 사용자모드는 제한, 커널모드에서는 메모리에 무제한 접근가능

## 11. CPU 보안

- CPU를 독점하면 다른 프로그램 및 운영체제가 빼앗을 방법이 없다.
- 그래서 타이머라는 하드웨어 사용
- 정해진 시간이 지나면 인터럽트 발생시켜 운영체제가 CPU 제어권 획득
- 타이머는 클럭 틱(clock tick) 때마다 1씩 감소. 0이되면 인터럽트
- 로드타이머(load timer): 타이머의 값을 세팅하는 명령. 특권명령에 속함
- 타이머는 시분할 시스템에서 현재 시간을 계산하기 위해서도 사용

## 12. 시스템 콜을 이용한 입출력 수행

- IO는 특권명령이므로 사용자 프로그램에서 수행 불가능.
- 시스텝콜 => 제어권 운영체제로 넘김 => 인터럽트 처리 루틴

# 4장. 프로그램의 구조와 실행

<!-- device controller
cpu는 메모리에서 하ㅏ씩읽어서 실행하는게 운명. interrupt를 읽음

register: 저장할수이슨 공간.
mode bit: 실행중인게 뭔지. 운영체제를 실행하는지 프로그램을 실행하는지
interrupt line: instruction 실행 => 주소값이 증가. 다음 사이클에서는 그다음 instruction 실행.
cpu는 무조건 메모리만 접근.
timer가 cpu 독점막음.
인스트력선: 명령어
cpu는 빠른 일꾼. 프로그램카운터라는 레지스토 주소에서 인스트럭션을 실행하는일만함.

cpu는 운영체제에게 제어권 넘김.
시스템콜. 사용자프로그램은 .
dma controller 역할: io에서 interu
커널함수호출할때는 시스테콜. -->
