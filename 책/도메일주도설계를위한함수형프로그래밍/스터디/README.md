# 1회차

유튜브로만 보던 강의를 직접 줌 스터디에 참여했는데 재밌었다.

기억에 남는 몇가지

- transaction은 거의 대부분의 경우에 필요없다. 쇼핑몰도 다음날 취소된다. 심지어 가끔은 결제로 그렇다. 개발자들만 trasnaction 필요하다고 생각한다. Eventual Consistency로 생각하는게 중요하다.
- 함수형은 은닉이 필요없다. 객체지향은 조작이 가능하니까 은닉이 필요한거다.
- 함수는 eager아니라 lazy다.

# 2회차

- post는 무조건 entity다.
- 댓글은 VO일까 엔티티일까? 개발자의 판단이다. VO로 가면 기존 리스트를 다 갔다버리고 새로운 리스트를 추가해야한다. 부하가 겁나지 않으면 해도 된다. 불변성가지고 id로 식별하지 않는다. 근데 늘어나면 런타임이 늘어나는 단점이 있다. 그래도 편해.
- VO는 무조건 정합성이 맞는다.
- 잘 모르면 일단 VO를 기본으로 하자.

```
table posts
id, title, content, user, commentJson, commentCount
```

commentJson방식으로 만들어도 된다. count하면 성능떨어진다고? 업데이트할때마다 commentCount업데이트 해주면돼.

- 재귀적인 cardinality는 무한집합이다.
- 합타입과 곱타입은 섞는게 아니다.(이거 진짜 공감. 나도 진짜 중요하게 생각함)

```
class Paayment{ // 두 개의 속성을 갖는 곱타입 클래스
  status:paid or pending, // 합타입속성
  paidDate:Date?
}

Payment{
  Pending{status:pending}
  Paid{status:padi, date:Date} // 1*N의 곱타입
}
// 문제가 해결되는 모델
```

- 핵심은 불변식이 합타입으로 표현되었는가

- 타입스크립트는 진짜 미쳤다.(좋은뜻) 특히 infer. 다른 언어는 컴파일타임에 추적하는거 없다.

- eventually consistency는 어느 시점에만 불변식이 유지되는거다. 즉 불변성 안지켜지는게 기본이다.(한글 번역 결과적 일관성인데 번역이 이상하다. 결과적일관성이 아니다.)
- continous consistency라고도 불린다. 지속적으로 일관성을 맞추기 위해 노력한다고 이해하면 쉽다.

- ddd는 불변식이 제일 중요하다. bounded contet, aggregate 모두 불변식이 기본이다.

- 이벤트 스토밍과 불변식은 닭과 달걀 관계다. 불변식을 먼저 뽑아도 되는데 그게 힘드니까 먼저 이벤트 스토밍을 하는거다.

- 타입스크립트 브랜드 예제 미쳤다. 다시보자.

- aggregate root는 무조건 엔티티다.
- 엔티티는 내부에 상태를 갖는다.
- 상태변경은 내부에서만 가능하다. 불변컨텍스트 아니다.
- 포인터의 포인터를 생각해라. 바깥 객체는 바꿀수없다.

- 불변식 처리하는건 클래스, 함수 모두 마찬가지로 가능하다.

사실 런타임 분기가 컴파일 타입보다 훨씬 쉽다. 대수타입이 이론적으론 좋은데 실무적으론 귀찮다.
